@page "/Tactics/{ID}"
@namespace Wildblood.Tactics.Components.Pages
@using Microsoft.AspNetCore.SignalR
@using Microsoft.AspNetCore.SignalR.Client
@using MongoDB.Bson
@using System.Text.Json
@using Wildblood.Tactics.Entities
@using MongoDB.Driver;
@using Wildblood.Tactics.Models
@using Icon = Wildblood.Tactics.Entities.Icon
@using Wildblood.Tactics.Components.Layout
@inject IJSRuntime JS;
@inject IMongoDatabase Database;
@inject IDialogService DialogService;
@inject NavigationManager NavigationManager

@rendermode InteractiveServer

@if (tactic == null)
{
    <div>Loading</div>
    return;
}

<div class="parent">
    <div style="grid-area: 1/1/span 7/2;" id="tacticsCanvasContainer">
        @*Width and Height is set via JS (=> 100% of size of parent container)*@
        <canvas id="tacticsCanvas" width="100%" height="100%" style="border:1px solid #000000;" @onmousedown="MouseDown" @onmouseup="dragStop" @onmousemove="dragMove" @onmousewheel="MouseScroll"></canvas>
        <img id="dragImage" src="" style="display:none" @onmouseup="dragStop"/>
    </div>
    <div id="MapSelectionDiv" style="grid-area:1/2/1/2">
        <MudSelect T="string" Label="Maps" ValueChanged="MapChanged">
            @foreach (var map in maps)
            {
                <MudSelectItem Value="@map">@map</MudSelectItem>
            }
        </MudSelect>
    </div>
    <MudPaper style="grid-area:2/2/span 3/2">
        <MudTabs>
            <MudTabPanel Icon="@swordsIcon" @onclick="() => ChangeTool(IconType.Unit)">
                <div>
                    @*Unit*@
                    <MudPaper Class="flex-wrap d-flex" Width="300px">
                        @foreach (var unit in units)
                        {
                            <MudPaper Class="ma-1" @onclick="@(async (args) => await selectedUnitChanged(unit))">
                                <img src="/ConquerorsBladeData/Units/@unit" height="40" width="40" />
                            </MudPaper>

                        }
                    </MudPaper>
                </div>
            </MudTabPanel>
            <MudTabPanel Icon="@vectorLineIcon" @onclick="() => ChangeTool(IconType.StraightLine)">
                <MudPaper>
                    <MudColorPicker Label="Line Color" @bind-Text="colorValue" />
                </MudPaper>
            </MudTabPanel>
        </MudTabs>
    </MudPaper>


    <div style="grid-area: 5/2/span 3/2; overflow-y: scroll; min-height:200px">
        <MudPaper>
            <MudTreeView T="Tactic" Hover="true" Dense="true" ExpandOnClick="true">
                <MudTreeViewItem Icon="@Icons.Material.Outlined.Map">
                    <BodyContent>
                        <div style="display: grid; grid-template-columns: 1fr auto; align-items: center; width: 100%">
                            <MudText>@tactic.Name</MudText>
                            <div style="justify-self: end;">
                                <MudIconButton Icon="@Icons.Material.Filled.Edit" @onclick="@(async (args) => await onClickTacticRename())" />
                                <MudIconButton Icon="@Icons.Material.Filled.AddBox" @onclick="@(async (args) => await OnAddFolder())" />
                            </div>
                        </div>
                    </BodyContent>
                    <ChildContent>
                        @foreach (var folder in tactic.Folders)
                        {
                            <MudTreeViewItem Icon="@Icons.Material.Filled.Folder">
                                <BodyContent>
                                    <div style="display: grid; grid-template-columns: 1fr auto; align-items: center; width: 100%">
                                        <MudText>@folder.Name</MudText>
                                        <div style="justify-self: end;">
                                            <MudIconButton Icon="@Icons.Material.Filled.Edit" @onclick="@(async (args) => await OnClickFolderRename(folder.Id))" />
                                            <MudIconButton Icon="@Icons.Material.Filled.AddBox" @onclick="@(async (args) => await OnAddSlide(folder.Id))" />
                                        </div>
                                    </div>
                                </BodyContent>
                                <ChildContent>
                                    @foreach (var slide in folder.Slides)
                                    {
                                        <MudTreeViewItem Icon="@Icons.Material.Filled.Notes" @onclick="@(async (args) => await OnSelectedSlideChange(slide, folder))">
                                            <BodyContent>
                                                <div style="display: grid; grid-template-columns: 1fr auto; align-items: center; width: 100%">
                                                    <MudText>@slide.Name</MudText>
                                                    <div style="justify-self: end;">
                                                        <MudIconButton Icon="@Icons.Material.Filled.Edit" @onclick="@(async (args) => await onclickSlideRename(slide.Id, folder.Id))" />
                                                    </div>
                                                </div>
                                            </BodyContent>
                                        </MudTreeViewItem>
                                    }
                                </ChildContent>
                            </MudTreeViewItem>
                        }
                    </ChildContent>
                </MudTreeViewItem>
            </MudTreeView>
        </MudPaper>
        <MudPaper>
            <MudIconButton Icon="@Icons.Material.Filled.ZoomOut" @onclick="() => SetZoom(zoomLevel - 0.1)"></MudIconButton>
            <span>@zoomLevel.ToString("0.0")x</span>
            <MudIconButton Icon="@Icons.Material.Filled.ZoomIn" @onclick="() => SetZoom(zoomLevel + 0.1)">+</MudIconButton>
        </MudPaper>
    </div>
</div>

@code {



    [Parameter]
    public string? ID { get; set; }

    private HubConnection? hubConnection;
    private Tactic? tactic;
    private string colorValue;
    private Slide currentSlide;
    private Folder currentFolder;
    private IconType currentTool = IconType.Unit;
    private IconType currentDraggingType = IconType.Unit;
    private static string baseMapPath = "wwwroot/ConquerorsBladeData/Maps";
    private static string baseUnitPath = "wwwroot/ConquerorsBladeData/Units";
    private string selectedUnit;
    private IMongoCollection<Tactic> collection;

    private List<string> maps = new List<string>();
    private List<string> units = new List<string>();
    private Icon draggingIcon;
    private Icon drawableIcon;
    private bool drawingShape = false;
    private bool isDragging = false;
    private int draggingIconIndex;
    private double startX;
    private double startY;
    private bool needsCanvasRedraw = false;
    private double zoomLevel = 1.0;
    private bool isPanning = false;
    private double panStartX, panStartY;
    private double panOriginX, panOriginY;
    private double panX = 0, panY = 0;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        maps = Directory.EnumerateFiles(baseMapPath, "*", SearchOption.AllDirectories)
            .Select(f => Path.GetFileName(f)
            .Split('.')[0])
            .ToList();
        units = Directory.EnumerateFiles(baseUnitPath, "*", SearchOption.AllDirectories)
            .Select(f => Path.GetFileName(f))
            .ToList();


    }

    protected override async void OnParametersSet()
    {
        if (ID != null)
        {
            collection = Database.GetCollection<Tactic>("Tactics");
            tactic = collection.Find(t => t.Id == ID).FirstOrDefault();
            currentFolder = tactic.Folders[0];
            currentSlide = currentFolder.Slides[0];
            colorValue = "#000000";
        }

        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }

        hubConnection = new HubConnectionBuilder()
        .WithUrl(NavigationManager.ToAbsoluteUri("/tacticsHub"), options =>
        {
            options.HttpMessageHandlerFactory = handler =>
        {
            if (handler is HttpClientHandler clientHandler)
            {
                clientHandler.ServerCertificateCustomValidationCallback =
                    HttpClientHandler.DangerousAcceptAnyServerCertificateValidator;
            }
            return handler;
        };
        })
        .WithAutomaticReconnect()
        .Build();

        hubConnection.On<string, object, object, object>("ReceiveTacticUpdate", async (tacticId, updatedData, slideId, folderId) =>
        {
            if (tacticId == ID)
            {
                Console.WriteLine($"Received update for tactic {tacticId}");
                var json = updatedData.ToString();
                var slideStringId = slideId.ToString();
                var folderStringId = folderId.ToString();
                var options = new JsonSerializerOptions()
                {
                    PropertyNameCaseInsensitive = true,
                };

                tactic = JsonSerializer.Deserialize<Tactic>(json, options);

                if (slideStringId == currentSlide.Id && folderStringId == currentFolder.Id)
                {
                    currentSlide = tactic.Folders.Single(folder => folder.Id == folderStringId).Slides.Single(slide => slide.Id == slideStringId);
                    currentFolder = tactic.Folders.Single(folder => folder.Id == folderStringId);
                    needsCanvasRedraw = true;
                }
                await InvokeAsync(StateHasChanged);
            }
        });

        hubConnection.On<string, string>("ReceiveTacticLock", async (tacticId, userId) =>
        {
            if (tacticId == ID)
            {
                Console.WriteLine($"Tactic {tacticId} locked by user {userId}");
            }
        });

        hubConnection.On<string>("ReceiveTacticUnlock", async (tacticId) =>
        {
            if (tacticId == ID)
            {
                Console.WriteLine($"Tactic {tacticId} unlocked");
            }
        });

        await hubConnection.StartAsync();

    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("setCanvasSize", "tacticsCanvas");
            var imageFilePaths = Directory.EnumerateFiles(baseUnitPath, "*.*", SearchOption.AllDirectories)
                .Where(file => new[] { ".png", ".jpg", ".jpeg", ".gif", ".bmp" }.Contains(Path.GetExtension(file).ToLower()))
                .Select(file => file.Replace("wwwroot", ""))
                .ToList();
            await JS.InvokeVoidAsync("preLoadImages", imageFilePaths);
            if (currentSlide.MapPath != null)
            {
                await JS.InvokeVoidAsync("setBackground", currentSlide.MapPath);
            }

            if (currentSlide.Icons.Any())
            {
                await JS.InvokeVoidAsync("draw", currentSlide.Icons);
            }
        }

        if (needsCanvasRedraw)
        {
            needsCanvasRedraw = false;
            await ReDrawCanvas();
        }
    }

    public Task selectedUnitChanged(string unit)
    {
        selectedUnit = unit;
        return Task.CompletedTask;
    }

    public async Task MapChanged(string map)
    {
        currentSlide.MapPath = map;
        await JS.InvokeVoidAsync("setBackground", map);
        var filter = Builders<Tactic>.Filter.Eq(t => t.Id, tactic.Id);
        var folderIndex = tactic.Folders.FindIndex(f => f.Id == currentFolder.Id);
        var slideIndex = tactic.Folders[folderIndex].Slides.FindIndex(s => s.Id == currentSlide.Id);
        var update = Builders<Tactic>.Update.Set(t => t.Folders[folderIndex].Slides[slideIndex].MapPath, map);
        await collection.UpdateOneAsync(filter, update);
    }


    private async Task placeIcon(double mouseX, double mouseY)
    {
        var unit = new Icon
        {
            StartX = mouseX,
            StartY = mouseY,
            EndX = mouseX + 40,
            EndY = mouseY + 40,
            FilePath = "/ConquerorsBladeData/Units/" + selectedUnit,
            Type = IconType.Unit,
            Color = colorValue,
        };

        await JS.InvokeVoidAsync("placeIcon", unit);

        currentSlide.Icons.Add(unit);
        var folderIndex = tactic.Folders.FindIndex(f => f.Id == currentFolder.Id);
        var slideIndex = tactic.Folders[folderIndex].Slides.FindIndex(s => s.Id == currentSlide.Id);
        var filter = Builders<Tactic>.Filter.Eq(t => t.Id, tactic.Id);
        var update = Builders<Tactic>.Update.Push(t => t.Folders[folderIndex].Slides[slideIndex].Icons, unit);
        await collection.UpdateOneAsync(filter, update);
        await UpdateTactic();
    }

    private async Task MouseDown(MouseEventArgs eventArgs)
    {
        if (eventArgs.Button == 1)
        {
            isPanning = true;
            panStartX = eventArgs.ClientX;
            panStartY = eventArgs.ClientY;

            // Get current pan from JS (optional, if you want to sync)
            var pan = await JS.InvokeAsync<PanPosition>("getPan");
            panOriginX = pan.x;
            panOriginY = pan.y;
            return;
        }
        var pos = await JS.InvokeAsync<MousePosition>("getLogicalMousePosition", "tacticsCanvas", eventArgs.ClientX, eventArgs.ClientY);
        var mouseX = pos.x;
        var mouseY = pos.y;

        foreach (var icon in currentSlide.Icons)
        {
            if (CheckLineClicked(mouseX, mouseY, icon) ||
                CheckUnitClicked(mouseX, mouseY, icon))
            {
                draggingIcon = icon with {};
                draggingIconIndex = currentSlide.Icons.IndexOf(icon);
                isDragging = true;
                startX = mouseX;
                startY = mouseY;
                await JS.InvokeVoidAsync("startDrag", draggingIcon, mouseX, mouseY);
                currentSlide.Icons.Remove(icon);
                currentDraggingType = icon.Type;
                return;
            }
        }
        switch (currentTool)
        {
            case IconType.Unit:
                await placeIcon(mouseX, mouseY);
                return;
            case IconType.StraightLine:
                await setStartPointForArrow(mouseX, mouseY);
                drawingShape = true;
                return;
        }
    }

    private static double LineSegmentSDF(
        double px, double py,
        double x1, double y1, // line start
        double x2, double y2, // line end
        double width)         // full thickness
    {
        var lineLengthX = x2 - x1;
        var lineLengthY = y2 - y1;
        var lengthSq = lineLengthX * lineLengthX + lineLengthY * lineLengthY;

        if (lengthSq == 0)
        {
            var distanceToPoint = Math.Sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1)) - width * 0.5f;
            return distanceToPoint;
        }

        // Project point onto the line segment
        var normalizedProjection = ((px - x1) * lineLengthX + (py - y1) * lineLengthY) / lengthSq;
        normalizedProjection = Math.Max(0, Math.Min(1, normalizedProjection)); // Clamp to segment

        // Closest point on the segment
        var projectionX = x1 + normalizedProjection * lineLengthX;
        var projectionY = y1 + normalizedProjection * lineLengthY;

        // Distance to closest point
        var distance = (float)Math.Sqrt(
            (px - projectionX) *
            (px - projectionX) + (py - projectionY) *
            (py - projectionY));

        return distance - width * 0.5f; // signed: negative inside the stroke
    }

    private bool CheckLineClicked(double mouseX, double mouseY, Icon icon) =>
        icon.Type == IconType.StraightLine &&
        LineSegmentSDF(mouseX, mouseY, icon.StartX, icon.StartY, icon.EndX, icon.EndY, 10f) < 0;

    private bool CheckUnitClicked(double mouseX, double mouseY, Icon icon) =>
        icon.Type == IconType.Unit &&
        mouseX > icon.StartX && mouseX < icon.EndX && mouseY > icon.StartY && mouseY < icon.EndY;

    private async Task dragMove(MouseEventArgs args)
    {
        var pos = await JS.InvokeAsync<MousePosition>("getLogicalMousePosition", "tacticsCanvas", args.ClientX, args.ClientY);
        var mouseX = pos.x;
        var mouseY = pos.y;

        if ((!isDragging || draggingIcon == null) && !drawingShape && !isPanning)
        {
            return;
        }

        if (isPanning)
        {
            var dx = args.ClientX - panStartX;
            var dy = args.ClientY - panStartY;
            panX = panOriginX + dx;
            panY = panOriginY + dy;

            await JS.InvokeVoidAsync("setPan", panX, panY);
            return;
        }

        if (currentTool == IconType.StraightLine && drawingShape)
        {
            drawableIcon.EndX = mouseX;
            drawableIcon.EndY = mouseY;

            currentSlide.Icons.Add(drawableIcon);
            await JS.InvokeVoidAsync("draw", currentSlide.Icons);
            currentSlide.Icons.Remove(drawableIcon);
            return;
        }

        if (currentDraggingType == IconType.Unit)
        {
            draggingIcon.StartX = mouseX;
            draggingIcon.StartY = mouseY;
            draggingIcon.EndX = mouseX + 40;
            draggingIcon.EndY = mouseY + 40;

            currentSlide.Icons.Add(draggingIcon);
            await JS.InvokeVoidAsync("dragIcon", mouseX, mouseY, currentSlide.Icons);
            currentSlide.Icons.Remove(draggingIcon);
        }
        else if (currentDraggingType == IconType.StraightLine && !drawingShape)
        {
            var deltaX = mouseX - startX;
            var deltaY = mouseY - startY;

            draggingIcon.EndX += deltaX;
            draggingIcon.EndY += deltaY;
            draggingIcon.StartX += deltaX;
            draggingIcon.StartY += deltaY;

            startX = mouseX;
            startY = mouseY;
            currentSlide.Icons.Add(draggingIcon);
            await JS.InvokeVoidAsync("dragIcon", mouseX, mouseY, currentSlide.Icons);
            currentSlide.Icons.Remove(draggingIcon);
        }
    }

    private async Task dragStop(MouseEventArgs args)
    {
        if (!isDragging && !drawingShape && !isPanning)
        {
            return;
        }

        if (isPanning && args.Button == 1)
        {
            isPanning = false;
            return;
        }

        var folderIndex = tactic.Folders.FindIndex(f => f.Id == currentFolder.Id);
        var slideIndex = tactic.Folders[folderIndex].Slides.FindIndex(s => s.Id == currentSlide.Id);
        var filter = Builders<Tactic>.Filter.Eq(t => t.Id, tactic.Id);

        if (currentTool == IconType.StraightLine && drawingShape)
        {
            drawingShape = false;
            currentSlide.Icons.Add(drawableIcon);
            await JS.InvokeVoidAsync("draw", currentSlide.Icons);
            var insert = Builders<Tactic>.Update.Push(t => t.Folders[folderIndex].Slides[slideIndex].Icons, drawableIcon);
            await collection.UpdateOneAsync(filter, insert);
            return;
        }

        isDragging = false;
        currentSlide.Icons.Add(draggingIcon);
        await JS.InvokeVoidAsync("stopDrag");
        await JS.InvokeVoidAsync("draw", currentSlide.Icons);
        var update = Builders<Tactic>.Update.Set(t => t.Folders[folderIndex].Slides[slideIndex].Icons[draggingIconIndex], draggingIcon);
        await collection.UpdateOneAsync(filter, update);
        await UpdateTactic();
    }

    private async Task OnClickFolderRename(string folderID)
    {
        var folder = tactic.Folders.First(f => f.Id == folderID);
        var parameters = new DialogParameters<RenameDialog>
        {
            { "Name", folder.Name }
        };

        var dialog = await DialogService.ShowAsync<RenameDialog>("Rename", parameters);
        var newName = (await dialog.Result).Data.ToString();
        if (newName != null)
        {
            // it is infact a referece!
            folder.Name = newName;
            var filter = Builders<Tactic>.Filter.Eq(t => t.Id, tactic.Id);

            var folderIndex = tactic.Folders.FindIndex(f => f.Id == folderID);

            var update = Builders<Tactic>.Update.Set(t => t.Folders[folderIndex].Name, newName);
            await collection.UpdateOneAsync(filter, update);
        }
    }

    private async Task OnSelectedSlideChange(Slide slide, Folder folder)
    {
        if (currentFolder != folder)
        {
            currentFolder = folder;
        }

        currentSlide = slide;
        await ReDrawCanvas();

    }

    private async Task onclickSlideRename(string slideID, string folderID)
    {
        var slide = tactic.Folders.Single(f => f.Id == folderID).Slides.Single(s => s.Id == slideID);
        var parameters = new DialogParameters<RenameDialog>
        {
            { "Name", slide.Name }
        };

        var dialog = await DialogService.ShowAsync<RenameDialog>("Rename", parameters);
        var newName = (await dialog.Result).Data.ToString();
        if (newName != null)
        {
            slide.Name = newName;
            var filter = Builders<Tactic>.Filter.Eq(t => t.Id, tactic.Id);

            var folderIndex = tactic.Folders.FindIndex(f => f.Id == folderID);
            var slideIndex = tactic.Folders[folderIndex].Slides.FindIndex(s => s.Id == slideID);

            var update = Builders<Tactic>.Update.Set(t => t.Folders[folderIndex].Slides[slideIndex].Name, newName);
            await collection.UpdateOneAsync(filter, update);
        }
    }

    private async Task OnAddSlide(string folderID)
    {
        var newSlide = new Slide
        {
            Id = ObjectId.GenerateNewId().ToString(),
            Name = "New Slide",
            MapPath = null,
            Icons = new List<Icon>()
        };
        var filter = Builders<Tactic>.Filter.Eq(t => t.Id, tactic.Id) & Builders<Tactic>.Filter.ElemMatch(t => t.Folders, f => f.Id == folderID);
        var folderIndex = tactic.Folders.FindIndex(f => f.Id == folderID);
        var update = Builders<Tactic>.Update.Push(t => t.Folders[folderIndex].Slides, newSlide);
        await collection.UpdateOneAsync(filter, update);
        tactic.Folders.Single(f => f.Id == folderID).Slides.Add(newSlide);

    }

    private async Task onClickTacticRename()
    {
        var parameters = new DialogParameters<RenameDialog>
        {
            { "Name", tactic.Name }
        };

        var dialog = await DialogService.ShowAsync<RenameDialog>("Rename", parameters);
        var newName = (await dialog.Result).Data.ToString();
        if (newName != null)
        {
            tactic.Name = newName;
            //TODO currently im always replacing the entire document. Not good.
            var filter = Builders<Tactic>.Filter.Eq(t => t.Id, tactic.Id);
            var update = Builders<Tactic>.Update.Set(t => t.Name, newName);
            await collection.UpdateOneAsync(filter, update);
        }
    }

    private async Task OnAddFolder()
    {
        var newFolder = new Folder
        {
            Id = ObjectId.GenerateNewId().ToString(),
            Name = "New Folder",
            Slides = new List<Slide>(),
        };
        var filter = Builders<Tactic>.Filter.Eq(t => t.Id, tactic.Id);
        var update = Builders<Tactic>.Update.Push(t => t.Folders, newFolder);
        await collection.UpdateOneAsync(filter, update);
        tactic.Folders.Add(newFolder);
    }

    private async Task ReDrawCanvas()
    {
        await JS.InvokeVoidAsync("draw", currentSlide.Icons);
        await JS.InvokeVoidAsync("setBackground", currentSlide.MapPath);
    }

    private void ChangeTool(IconType selectedTool)
    {
        currentTool = selectedTool;
    }

    private async Task setStartPointForArrow(double mouseX, double mouseY)
    {
        drawableIcon = new Icon
        {
            StartX = mouseX,
            StartY = mouseY,
            EndX = mouseX,
            EndY = mouseY,
            FilePath = string.Empty,
            Type = IconType.StraightLine,
            Color = colorValue
        };
    }

    private async Task UpdateTactic()
    {
        if (hubConnection is not null)
        {
            Console.WriteLine($"Sending update for tactic {ID}");
            await hubConnection.SendAsync("UpdateTactic", ID, tactic, currentSlide.Id, currentFolder.Id);
        }
    }

    private async Task LockTactic()
    {
        if (hubConnection is not null)
        {
            Console.WriteLine($"Locking tactic {ID}");
            await hubConnection.SendAsync("LockTactic", ID, "currentUserId");
        }
    }

    private async Task UnlockTactic()
    {
        if (hubConnection is not null)
        {
            Console.WriteLine($"Unlocking tactic {ID}");
            await hubConnection.SendAsync("UnlockTactic", ID);
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }
    }

    private async Task MouseScroll(WheelEventArgs args)
    {
        zoomLevel -= args.DeltaY * 0.001; // Adjust the zoom speed as needed
        await SetZoom(zoomLevel);
    }

    private async Task SetZoom(double newZoom)
    {
        zoomLevel = Math.Max(0.1, newZoom);
        await JS.InvokeVoidAsync("setZoom", zoomLevel);
    }


    static string vectorLineIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><title>vector-line</title><path d=\"M15,3V7.59L7.59,15H3V21H9V16.42L16.42,9H21V3M17,5H19V7H17M5,17H7V19H5\" /></svg>";
    static string swordsIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><title>sword-cross</title><path d=\"M6.2,2.44L18.1,14.34L20.22,12.22L21.63,13.63L19.16,16.1L22.34,19.28C22.73,19.67 22.73,20.3 22.34,20.69L21.63,21.4C21.24,21.79 20.61,21.79 20.22,21.4L17,18.23L14.56,20.7L13.15,19.29L15.27,17.17L3.37,5.27V2.44H6.2M15.89,10L20.63,5.26V2.44H17.8L13.06,7.18L15.89,10M10.94,15L8.11,12.13L5.9,14.34L3.78,12.22L2.37,13.63L4.84,16.1L1.66,19.29C1.27,19.68 1.27,20.31 1.66,20.7L2.37,21.41C2.76,21.8 3.39,21.8 3.78,21.41L7,18.23L9.44,20.7L10.85,19.29L8.73,17.17L10.94,15Z\" /></svg>";
}